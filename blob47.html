<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gelly Blobs with Video</title>
<style>
html,body { height:100%; margin:0; }
body {
  display:flex;
  align-items:center;
  justify-content:center;
  background:#fff;
  overflow:hidden;
  font-family:Arial, Helvetica, sans-serif;
}
canvas { display:block; position:fixed; inset:0; z-index:1; }
.ui {
  position:relative;
  z-index:3;
  text-align:center;
  pointer-events:none;
  color:#111;
}
h1 { margin:0; font-size:clamp(28px,5vw,54px); font-weight:800; pointer-events:none; }
#exploreBtn {
  position:absolute;
  z-index:4;
  pointer-events:auto;
  transform:translate(-50%,-50%);
  padding:10px 16px;
  border-radius:8px;
  background:#111;
  color:#fff;
  border:0;
  font-weight:700;
  display:none;
  opacity:0;
  transition: opacity 0.3s ease;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="ui">
  <h1>THREE VIBRANT<br>DISTRICTS</h1>
</div>
<button id="exploreBtn">EXPLORE</button>

<!-- Video element -->
<video id="v" src="street.mp4" muted loop playsinline style="opacity:0; position:absolute; pointer-events:none;"></video>

<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
const video = document.getElementById('v');
const btn = document.getElementById('exploreBtn');

// Resize canvas
function resize() {
  c.width = window.innerWidth;
  c.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Mouse/touch
const mouse = { x: c.width/2, y: c.height/2 };
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('touchmove', e => {
  if(e.touches && e.touches[0]) { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }
}, { passive:true });

function makeBlob(cx, cy, radius, points, colors, label){
  const pts = [];
  for(let i=0;i<points;i++){
    const a = (i/points)*Math.PI*2;
    const px = cx + Math.cos(a)*radius;
    const py = cy + Math.sin(a)*radius;
    pts.push({ x:px, y:py, vx:0, vy:0, angle:a });
  }
  return { cx, cy, radius, points: pts, colors, label };
}

const blobs = [
  makeBlob(window.innerWidth*0.25, window.innerHeight*0.48, 140, 130, ['#ff6b3a','#ff3b00'], 'COVENT GARDEN'),
  makeBlob(window.innerWidth*0.50, window.innerHeight*0.48, 160, 166, ['#00c4c4','#009b9b'], 'VICTORIA EMBANKMENT'),
  makeBlob(window.innerWidth*0.75, window.innerHeight*0.48, 150, 138, ['#ffc35a','#ff8a00'], 'SOUTHBANK')
]; 

// const stiffness = 0.09;
// const damping = 0.97;
// const mouseForce = 170;
// const mouseRadius = 50;

const mouseForce = 50; // slower reaction
const mouseRadius = 90; // smoother falloff
const stiffness = 0.03; // softer motion
const damping = 0.70;   // slightly more damping




// Blob physics
function updateBlobPhysics(b, t){
  for(let i=0;i<b.points.length;i++){
    const p = b.points[i];
    const wobble = Math.sin(t*0.003 + p.angle*4 + i*0.02) * (b.radius*0.05);
    const tx = b.cx + Math.cos(p.angle)*(b.radius + wobble);
    const ty = b.cy + Math.sin(p.angle)*(b.radius + wobble);
    let fx = (tx - p.x) * stiffness;
    let fy = (ty - p.y) * stiffness;

    const dx = p.x - mouse.x;
    const dy = p.y - mouse.y;
    const d2 = dx*dx + dy*dy;
    if(d2 < mouseRadius*mouseRadius){
      const d = Math.sqrt(d2) || 1;
      const force = (1 - (d / mouseRadius)) * (mouseForce / (d + 20));
      fx += (dx / d) * force;
      fy += (dy / d) * force;
    }

    const prev = b.points[(i-1+b.points.length)%b.points.length];
    const next = b.points[(i+1)%b.points.length];
    fx += ((prev.x + next.x)/2 - p.x) * 0.025;
    fy += ((prev.y + next.y)/2 - p.y) * 0.025;

    p.vx = (p.vx + fx) * damping;
    p.vy = (p.vy + fy) * damping;
    p.x += p.vx;
    p.y += p.vy;
  }
}

// Draw helpers
function drawSmoothPath(points){
  const len = points.length;
  if(len === 0) return;
  ctx.beginPath();
  const p0 = points[0];
  ctx.moveTo(p0.x, p0.y);
  for(let i=1;i<len;i++){
    const prev = points[i-1];
    const cur = points[i];
    const midx = (prev.x + cur.x)/2;
    const midy = (prev.y + cur.y)/2;
    ctx.quadraticCurveTo(prev.x, prev.y, midx, midy);
  }
  const last = points[len-1];
  const first = points[0];
  ctx.quadraticCurveTo(last.x, last.y, (last.x+first.x)/2, (last.y+first.y)/2);
  ctx.closePath();
}

function drawBlobGradient(b){
  drawSmoothPath(b.points);
  const grad = ctx.createLinearGradient(b.cx - b.radius, b.cy - b.radius, b.cx + b.radius, b.cy + b.radius);
  grad.addColorStop(0, b.colors[0]);
  grad.addColorStop(1, b.colors[1]);
  ctx.fillStyle = grad;
  ctx.fill();
}

function drawCurvedLabel(b){
  const text = b.label || '';
  if(!text) return;
  const pts = b.points;
  let bestIdx = 0;
  let bestAngDiff = 1e9;
  for(let i=0;i<pts.length;i++){
    const ang = Math.atan2(pts[i].y - b.cy, pts[i].x - b.cx);
    const diff = Math.abs(ang + Math.PI/2);
    if(diff < bestAngDiff){ bestAngDiff = diff; bestIdx = i; }
  }
  ctx.save();
  ctx.fillStyle = '#111';
  ctx.font = '600 14px Arial';
  ctx.textBaseline = 'middle';
  const charSpacing = Math.round(pts.length / (text.length*5));
  let offset = -Math.floor(text.length/2);
  for(let i=0;i<text.length;i++){
    const idx = (bestIdx + (offset + i) * charSpacing + pts.length) % pts.length;
    const p = pts[idx];
    const nxt = pts[(idx+1)%pts.length];
    const angle = Math.atan2(nxt.y - p.y, nxt.x - p.x);
    const normal = angle - Math.PI/2;
    const x = p.x + Math.cos(normal)*(b.radius*0.1+10);
    const y = p.y + Math.sin(normal)*(b.radius*0.1+10);
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(angle);
    ctx.fillText(text[i],0,0);
    ctx.restore();
  }
  ctx.restore();
}

function isMouseOverBlob(b){
  const dx = mouse.x - b.cx;
  const dy = mouse.y - b.cy;
  return Math.sqrt(dx*dx + dy*dy) < b.radius * 1.15;
}

// Main loop
let hoveredBlob = null;
let videoAlpha = 0;

function loop(t){
  ctx.clearRect(0,0,c.width,c.height);
  hoveredBlob = null;

  for(const b of blobs){
    updateBlobPhysics(b, t);
    if(!isMouseOverBlob(b)){
      drawBlobGradient(b);
      drawCurvedLabel(b);
    } else {
      hoveredBlob = b;
      drawBlobGradient(b);
    }
  }

  if(hoveredBlob && video.readyState >= 2){
    videoAlpha += 0.05; videoAlpha = Math.min(1, videoAlpha);

    ctx.save();
    drawSmoothPath(hoveredBlob.points);
    ctx.clip();

    const bw = hoveredBlob.radius*2.2;
    const bh = hoveredBlob.radius*2.2;
    const aspect = video.videoWidth/video.videoHeight || 16/9;
    let dw, dh;
    if(aspect >= 1){ dw = Math.min(bw, bh*aspect); dh = dw/aspect; }
    else{ dh = Math.min(bh, bw/aspect); dw = dh*aspect; }

    ctx.globalAlpha = videoAlpha;
    ctx.drawImage(video, hoveredBlob.cx - dw/2, hoveredBlob.cy - dh/2, dw, dh);
    ctx.globalAlpha = 1;
    ctx.restore();

    drawCurvedLabel(hoveredBlob);

    btn.style.left = hoveredBlob.cx+'px';
    btn.style.top = hoveredBlob.cy+'px';
    btn.style.display='block';
    btn.style.opacity=1;

    if(video.paused) video.play().catch(()=>{});
  } else {
    videoAlpha -= 0.05; videoAlpha = Math.max(0, videoAlpha);

    if(videoAlpha > 0 && hoveredBlob){
      ctx.save();
      drawSmoothPath(hoveredBlob.points);
      ctx.clip();
      const bw = hoveredBlob.radius*2.2;
      const bh = hoveredBlob.radius*2.2;
      const aspect = video.videoWidth/video.videoHeight || 16/9;
      let dw, dh;

      if(aspect >= 1){ dw = Math.max(bw, bh*aspect); dh = dw/aspect; }
else{ dh = Math.max(bh, bw/aspect); dw = dh*aspect; }


    //   if(aspect >= 1){ dw = Math.min(bw, bh*aspect); dh = dw/aspect; }
    //   else{ dh = Math.min(bh, bw/aspect); dw = dh*aspect; }
      ctx.globalAlpha = videoAlpha;
      ctx.drawImage(video, hoveredBlob.cx - dw/2, hoveredBlob.cy - dh/2, dw, dh);
      ctx.globalAlpha = 1;
      ctx.restore();
      drawCurvedLabel(hoveredBlob);
    }

    btn.style.opacity=0;
    setTimeout(()=>{ if(!hoveredBlob) btn.style.display='none'; },300);
    if(!video.paused) video.pause();
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// EXPLORE button click
btn.addEventListener('click', ()=>{
  btn.animate([{ transform:'translate(-50%,-50%) scale(1)'},{transform:'translate(-50%,-50%) scale(0.96)'}],{duration:120,easing:'ease-out'});
});

// Unlock autoplay
function unlockVideo() {
  video.muted = true;
  video.play().catch(e=>console.log("Autoplay blocked:", e));
  window.removeEventListener("click", unlockVideo);
  window.removeEventListener("mousemove", unlockVideo);
}
window.addEventListener("click", unlockVideo);
window.addEventListener("mousemove", unlockVideo);

window.addEventListener('resize', ()=>{
  blobs[0].cx = window.innerWidth*0.25; blobs[0].cy = window.innerHeight*0.48;
  blobs[1].cx = window.innerWidth*0.50; blobs[1].cy = window.innerHeight*0.48;
  blobs[2].cx = window.innerWidth*0.75; blobs[2].cy = window.innerHeight*0.48;
});
</script>
</body>
</html>
